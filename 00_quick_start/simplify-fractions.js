//import { assert } from "chai"

// assert
// typeof Chai

// import mocha from  "c:/Users/rickm/node_modules/mocha/lib/mocha"
// import * as hi from "./leetcode";

// import * as mod from "./leetcode";

// import * as  assert  from "chai"

// import { requireOrImport } from "mocha/lib/nodejs/esm-utils";
// import  * as mod2 from "C:\\Users\\rickm\\node_modules\\mocha\\lib\\mocha.js"
// import * as mochavar from 'C:\\Users\\rickm\\node_modules\\mocha\\node_modules\\mocha\\index.js'

// const Mocha = require("mocha/lib/mocha");
const mod=require("C:\\Users\\rickm\\node_modules\\mocha\\index.js")
const mod2=require("C:\\Users\\rickm\\node_modules\\mocha\\index.js")

const mod3=require("C:\\Users\\rickm\\.wallaby\\tutorial\\wallaby-tutorial\\node_modules\\mocha\\lib\\mocha.js")

console.log(mod3)
let newmod=new mod3()

const modobj=newmod

newmod


let func2=module.require.extensions[".js"]




// Object.keys(modobj)


// console.log(mod2)
// let func=new mod2.arguments

// new func()

// import {
//     describe
// } from "mocha"

// import { describe } as ddd from "C:\\Users\\rickm\\node_modules\\mocha\\lib\\mocha.js"

// describe


// let another=mod2.prototype['constructor']


// const variable = new Mocha(mod2.describe)

// Mocha
// typeof variable



// let new1=mod2.constructor
//.describe

// another.name

// let str1=
// C:\Users\rickm\AppData\Local\Microsoft\TypeScript\5.4\node_modules\@types\mocha\index.d.ts`
// str1

// C:\Users\rickm\.wallaby\tutorial\wallaby-tutorial\00_quick_start\simplify-fractions.js

// Mocha

module.exports

// import Mocha from "C:\\Users\\rickm\\.wallaby\\tutorial\\wallaby-tutorial\\node_modules\\mocha\\lib\\mocha.js"
// Mocha

// mod3


/*
mod3.describe('Array', function() {
        describe('#indexOf()', function() {
          it('should return -1 when not present', function() {
            // ...
          });

          it('should return the index when present', function() {
            // ...
          });
        });
      });


// let new2=Mocha


// Asd
// Mocha

another
// another()

const proto=mod2.prototype.constructor

proto.describe

// for (let whole in proto){
//     typeof whole
// }

// let ok2=proto.describe

class Calculator {
    add(a, b) {
        return a + b
    }
    multiply(a, b) {
        if (a >= 1 && b >= 1) {
            return a * b
        }

        return 0
    }
}

proto.describe("Calculator", () => {
    it("add", ()=>{
        const calc=new Calculator()
    })
})

// describe('thing', () => {
//     it('is a calculator', () => {
//         const calc =new Calculator()
//         expect(calc.add(3,1)).toBe(4)
//     });
// });

let newthing=new proto
typeof newthing

let vals=[]
const pusher=[]

let double=Object.entries(proto)

// double.flat(20)//.indexOf("teardown")

double[0]

double.flat()

// for (let [k,v] in mocha1){

//     // typeof k
//     // typeof v


//     pusher.push(k)
//     vals.push(v)
// }




let entries = Object.entries(mod2)

entries

// var describe: Mocha.SuiteFunction
// (title: string, fn: (this: Mocha.Suite) => void) => Mocha.Suite (+1 overload)


// var newthing=mod2.describe('', () => {
//     it('', () => {
        
//     });
// });

// var describe= Mocha.SuiteFunction

const instance = mod2

Object.entries(mod2)

// "@types/mocha": "10.0.6"
// let f = mod2.describe
// const describe = Mocha.SuiteFunction

// describe('thing', () => {
//     it('is a calculator', () => {
//         const calc =new Calculator()
//         expect(calc.add(3,1)).toBe(4)
//     });
// });

//   describe('calculator', () => {
//     it('adds numbers', () => {
//       const calculator = new Calculator()
//       expect(calculator.add(4, 3)).toBe(7)
//       calculator.add(150, 300) //?
//     })

//     it('multiplies numbers', () => {
//       const calculator = new Calculator();
//       expect(calculator.multiply(0, 2)).toBe(0);
//       expect(calculator.multiply(2, 0)).toBe(0);
//       expect(calculator.multiply(2, 2)).toBe(4);
//     })
//   })


// describe("Solution", function(){
//     it("should remove the correct element", function(){
//       Test.assertSimilar(remove([1, 2, 3], 2), [1, 2], "Wrong! Try again.");
//       Test.assertSimilar(remove([1, 2, 3, 4, 5, 6, 2, 1, 5, 3], 8), [1, 2, 3, 4, 5, 6, 2, 1, 3], "Wrong! Try again.");
//       Test.assertSimilar(remove(["1,2,3,4,5", "test", 7, {obj: "obj"}, [8,2,5]], 3), ["1,2,3,4,5", "test", 7, [8,2,5]], "Wrong! Try again.");
//       Test.assertSimilar(remove(["dog", "cat", "bat", "parrot", "monkey"], 4), ["dog", "cat", "bat", "parrot"], "Wrong! Try again.");
//     });
//     it("should return original array if index is out of range", function(){
//       Test.assertSimilar(remove([1, 2, 3], 20), [1, 2, 3], "Wrong! Try again.");
//       Test.assertSimilar(remove([1, 2, 3, 4, 5, 6, 2, 1, 5, 3], 17), [1, 2, 3, 4, 5, 6, 2, 1, 5, 3], "Wrong! Try again.");
//       Test.assertSimilar(remove(["1,2,3,4,5", "test", 7, {obj: "obj"}, [8,2,5]], -19), ["1,2,3,4,5", "test", 7, {obj: "obj"}, [8,2,5]], "Wrong! Try again.");
//       Test.assertSimilar(remove(["dog", "cat", "bat", "parrot", "monkey"], -1), ["dog", "cat", "bat", "parrot", "monkey"], "Wrong! Try again.");
//     });
//   })



// let simp=simplifiedFractions
// let simp2=new simplifiedFractions()


// let obj=mocha

let hex = 0x00000000

let [bits, bits2, bits3] = [0x00000010, 0x00000020, 0x00000030]

let big2 = bits ** bits2

big2.toString().slice(2, -4);

let s = (2 / 3).toExponential()
// let s=(2/3).toExponential()
s.slice(2, -3)

20 / 30

let eight = 98
let three = 33
let one = 11

// let one=11





// let mocha_array=Object.entries(mocha)
// let i=mocha_array.toString().indexOf("describe")

// let mocha_string=String(mocha_array)

// console.log(mocha_string.slice(i))

// mocha_array


// let arr= Array
// let o2={length: 25, k: ()=>""}

// arr.from(o2)

// arr[0]
// arr.length


// let code=20320
// code.toString(2)

// const inter=new Intl.NumberFormat

// number.toLocaleString("")

// TODO: Replace examples and use TDD development by writing your own tests

// These are some CW specific test methods available:
//    Test.expect(boolean, [optional] message)
//    Test.assertEquals(actual, expected, [optional] message)
//    Test.assertSimilar(actual, expected, [optional] message)
//    Test.assertNotEquals(actual, expected, [optional] message)

// NodeJS assert is also automatically required for you.
//    assert(true)
//    assert.strictEqual({a: 1}, {a: 1})
//    assert.deepEqual({a: [{b: 1}]}, {a: [{b: 1}]})

// You can also use Chai (http://chaijs.com/) by requiring it yourself
// var expect = require("chai").expect;
// var assert = require("chai").assert;
// require("chai").should();

/*
var simplifiedFractions2 = (num) => {

    let index = 1
    const array = []

    const set = new Set()

    while (index <= num) {

        // let nestedIndex = index + 1

        // for (let nestedIndex = index + 1; nestedIndex <= num; nestedIndex++) {

        let nestedIndex = index
        while (nestedIndex++ < num) {

            nestedIndex
            num

            let quotient = (index / nestedIndex)
            // let quotient = BigInt(index / nestedIndex)
            typeof quotient

            index
            nestedIndex

            let fraction_as_string = `${index} / ${nestedIndex}`
            const the_fraction_is_unique = !set.has(quotient)

            if (the_fraction_is_unique) {
                set.add(fraction_as_string)
            }
            set.add(quotient)

            set.add(index + "/" + nestedIndex)

            // nestedIndex++

        }
        index++

    }

    set

    let strings = [...set].filter((e, i) => i % 2 == 1)

    return strings

    return [...set].filter((e, i) => i % 2 == 1)


}

// export default simplifiedFractions2

console.log(simplifiedFractions2(4),
    ["1/2", "1/3", "1/4", "2/3", "3/4"])

let result = ""
let inc = 0

do {
    inc++
    console.log(inc, "\n", result)
    console.log(inc)
    console.log("\n")
    console.log(result)

    result += `${inc}`
}

while (inc > 0 && inc < 5)


// describe('calculator', () => {
//     it('adds numbers', () => {
//       expect(simplifiedFractions(4)).toBe(["1/2","1/3","1/4","2/3","3/4"])
//       simplifiedFractions(5) //?
//     })
// })

// it('multiplies numbers', () => {
//   const calculator = new Calculator();
//   expect(calculator.multiply(0, 2)).toBe(0);
//   expect(calculator.multiply(2, 0)).toBe(0);
//   expect(calculator.multiply(2, 2)).toBe(4);
// }
*/
